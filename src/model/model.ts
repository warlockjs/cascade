import {
  areEqual,
  clone,
  except,
  GenericObject,
  get,
  merge,
  only,
  set,
} from "@mongez/reinforcements";
import { isEmpty, isPlainObject } from "@mongez/supportive-is";
import { toUTC } from "@mongez/time-wizard";
import dayjs from "dayjs";
import { MongoServerError, ObjectId } from "mongodb";
import { castModel } from "../casts/castModel";
import { castEnum } from "../casts/oneOf";
import { deepDiff } from "../utils/deep-diff";
import { joinableProxy } from "../utils/joinable-proxy";
import { CrudModel } from "./crud-model";
import { Joinable } from "./joinable";
import { ModelAggregate } from "./ModelAggregate";
import { ModelSync } from "./ModelSync";
import { RelationshipWithMany } from "./RelationshipWithMany";
import type {
  Casts,
  CastType,
  ChildModel,
  CustomCasts,
  CustomCastType,
  Document,
  ModelDocument,
} from "./types";
import { ModelDeleteStrategy } from "./types";

// type Schema = Document | ModelDocument;

export type Schema<ModelSchema = Document> = ModelSchema & {
  _id?: ObjectId;
  id?: number;
  createdAt?: Date;
  updatedAt?: Date;
};

export class Model
  // <
  //   ModelDocument extends Document = any,
  //   Schema extends Schema<ModelDocument> = any,
  // >
  extends CrudModel
{
  /**
   * Model Initial Document data
   */
  public initialData: Partial<Schema> = {};

  /**
   * Model relationships defined using the joinable API.
   *
   * Each key represents a relationship name that can be referenced when running queries.
   * Each value defines how to join another collection to the current model.
   *
   * @example
   * Basic definition:
   * ```ts
   * public static relations = {
   *   // Join users collection where local createdBy.id matches user's id
   *   author: User.joinable("createdBy.id", "id").single().as("author"),
   * }
   * ```
   * @usage
   * Example of calling:
   * ```ts
   * Post.aggregate().joining("author").get(); // use `joining` method to join the `author` relationship
   * // Where `author` is the name of the relationship defined in the `relations` property
   * ```
   */
  public static relations: Record<string, Joinable> = {};

  /**
   * Model Document data
   */
  public data!: Schema;

  /**
   * Define Default value data that will be merged with the models' data
   * on the create process
   */
  public defaultValue: Partial<Schema> = {};

  /**
   * A flag to determine if the model is being restored
   */
  protected isRestored = false;

  /**
   * Model casts types
   */
  protected casts: Casts = {};

  /**
   * Sync with list
   */
  public syncWith: ModelSync[] = [];

  /**
   * Set custom casts that will be used to cast the model's data are not related to the current value of the collection's column
   *
   * For example: `name` is not a column in the given data, but it will be concatenation of `firstName` and `lastName`
   */
  protected customCasts: CustomCasts<string> = {};

  /**
   * Guarded fields
   */
  public guarded: (keyof ModelDocument)[] = [];

  /**
   * Fillable fields
   */
  public filled: (keyof ModelDocument)[] = [];

  /**
   * Embedded columns
   */
  public embedded: (keyof Schema)[] = [];

  /**
   * Embed all columns except the given columns
   */
  public embedAllExcept: (keyof ModelDocument)[] = [];

  /**
   * Embed all columns except timestamps and created|updated|deleted by columns
   */
  public embedAllExceptTimestampsAndUserColumns = false;

  /**
   * Created at column
   */
  public createdAtColumn = "createdAt";

  /**
   * Updated at column
   */
  public updatedAtColumn = "updatedAt";

  /**
   * Deleted at column
   */
  public deletedAtColumn = "deletedAt";

  /**
   * Created by column
   */
  public createdByColumn = "createdBy";

  /**
   * Updated by column
   */
  public updatedByColumn = "updatedBy";

  /**
   * Deleted by column
   */
  public deletedByColumn = "deletedBy";

  /**
   * Date format
   */
  public dateFormat = "DD-MM-YYYY";

  /**
   * A flag to determine if the id is auto generated not added manually
   */
  protected autoGeneratedId = false;

  /**
   * Is active column
   */
  protected isActiveColumn = "isActive";

  /**
   * Original data
   */
  public originalData: Schema = {} as Schema;

  /**
   * List of dirty columns
   */
  public dirtyColumns: Record<
    string,
    {
      oldValue: any;
      newValue: any;
    }
  > = {};

  /**
   * Constructor
   */
  public constructor(originalData: Partial<Schema> = {}) {
    super();

    if (originalData instanceof Model) {
      this.originalData = clone(originalData.data) as Schema;
    } else {
      this.originalData = clone(originalData) as Schema;
    }

    if (typeof this.originalData._id === "string") {
      this.originalData._id = new ObjectId(this.originalData._id);
    }

    this.data = clone(this.originalData);

    this.initialData = clone(this.originalData);
  }

  /**
   * Get save columns which are the casts keys
   */
  public get castColumns() {
    return Object.keys(this.casts);
  }

  /**
   * Get value from original data
   */
  public original(key: string, defaultValue?: any) {
    return get(this.originalData, key, defaultValue);
  }

  /**
   * Get all data except the guarded fields
   */
  public get publicData() {
    return except(this.data, this.guarded as string[]);
  }

  /**
   * Get guarded data
   */
  public get guardedData() {
    return only(this.data, this.guarded as string[]);
  }

  /**
   * Get the model's id
   */
  public get id(): number {
    return this.get("id");
  }

  /**
   * Check if current model is active
   */
  public get isActive() {
    return this.bool(this.isActiveColumn);
  }

  /**
   * Check if current model created by the given user (user model)
   */
  public isCreatedBy(user: Model) {
    return this.get("createdBy.id") === user.id;
  }

  /**
   * Check if current model last updated by the given user (user model)
   */
  public isUpdatedBy(user: Model) {
    return this.get("updatedBy.id") === user.id;
  }

  /**
   * Get mongodb id
   */
  public get _id(): ObjectId {
    return this.get("_id");
  }

  /**
   * Mark the current model as being restored
   */
  public markAsRestored() {
    this.isRestored = true;
  }

  /**
   * Set a column in the model data
   */
  public set(column: keyof Schema, value: any) {
    const currentValue = this.get(column);
    this.data = set(this.data, column as string, value) as Schema;

    if (currentValue !== value) {
      set(this.dirtyColumns, column as string, {
        oldValue: currentValue,
        newValue: value,
      });
    }

    return this;
  }

  /**
   * Increment the given column by the given value
   */
  public increment(column: keyof Schema, value = 1) {
    return this.set(column, this.get(column, 0) + value);
  }

  /**
   * Decrement the given column by the given value
   */
  public decrement(column: keyof Schema, value = 1) {
    return this.set(column, this.get(column, 0) - value);
  }

  /**
   * Get initial value of the given column
   */
  public getInitial(column: keyof Schema, defaultValue?: any) {
    return get(this.initialData, column as string, defaultValue);
  }

  /**
   * Get value of the given column
   */
  public get<ValueType = any>(
    column: keyof Schema,
    defaultValue?: any,
  ): ValueType {
    return get(this.data, column as string, defaultValue);
  }

  /**
   * Return the value of the given column as a string
   */
  public string(column: keyof Schema, defaultValue?: any) {
    return String(this.get(column, defaultValue));
  }

  /**
   * Return the value of the given column as an integer
   */
  public int(column: keyof Schema, defaultValue?: any) {
    return parseInt(this.get(column, defaultValue));
  }

  /**
   * Return the value of the given column as a float
   */
  public float(column: keyof Schema, defaultValue?: any) {
    return parseFloat(this.get(column, defaultValue));
  }

  /**
   * Return the value of the given column as a number
   */
  public number(column: keyof Schema, defaultValue?: any) {
    return Number(this.get(column, defaultValue));
  }

  /**
   * Return the value of the given column as a boolean
   */
  public bool(column: keyof Schema, defaultValue?: any) {
    return Boolean(this.get(column, defaultValue));
  }

  /**
   * Determine whether the given column exists in the document
   */
  public has(column: keyof Schema) {
    return get(this.data, column as string) !== undefined;
  }

  /**
   * Get all columns except the given ones
   */
  public except(columns: (keyof Schema)[]): Document {
    return except(this.data, columns as string[]);
  }

  /**
   * Get only the given columns
   */
  public only<T extends Document = Document>(columns: (keyof Schema)[]): T {
    return only(this.data, columns as string[]);
  }

  /**
   * Get only id
   */
  public get onlyId() {
    return this.only(["id"]);
  }

  /**
   * Unset or remove the given columns from the data
   */
  public unset(...columns: (keyof Schema)[]) {
    const currentValues = this.only(columns);
    this.data = except(this.data, columns as string[]);

    for (const column in currentValues) {
      set(this.dirtyColumns, column, {
        oldValue: currentValues[column],
        newValue: undefined,
      });
    }

    return this;
  }

  /**
   * Get the value of the given column and remove it from the data
   */
  public pluck(column: keyof Schema) {
    const value = this.get(column);
    this.unset(column);
    return value;
  }

  /**
   * Replace the entire document data with the given new data
   */
  public replaceWith(data: Schema) {
    if (!data.id && this.data.id) {
      data.id = this.data.id;
    }

    if (!data._id && this.data._id) {
      data._id = this.data._id;
    }

    const currentData = clone(data);

    this.data = data;

    const dirtyValues = deepDiff(currentData, this.data);

    merge(this.dirtyColumns, dirtyValues);

    return this;
  }

  /**
   * Merge the given documents to current document
   */
  public merge(data: Document) {
    const currentData = clone(this.data);

    this.data = merge(this.data, data);

    const dirtyValues = deepDiff(currentData, this.data);

    merge(this.dirtyColumns, dirtyValues);

    for (const column in this.data) {
      if (this.data[column] !== currentData[column]) {
        set(this.dirtyColumns, column, {
          oldValue: currentData[column],
          newValue: this.data[column],
        });
      }
    }

    return this;
  }

  /**
   * Push the given values to the given column
   * If the given column does not exists, it will be created
   * If the given value exists but not an array it will be ignored
   */
  public push(column: keyof Schema, ...values: any[]) {
    const currentValue = this.get(column);

    if (Array.isArray(currentValue)) {
      this.set(column, [...currentValue, ...values]);
    } else if (!currentValue) {
      this.set(column, values);
    }

    return this;
  }

  /**
   * Push the given values to the given column only if not exists
   */
  public pushOnce(column: keyof Schema, ...values: any[]) {
    const currentValue = this.get(column);

    if (Array.isArray(currentValue)) {
      const newValues = Array.from(new Set([...currentValue, ...values]));
      this.set(column, newValues);
    } else if (!currentValue) {
      this.set(column, values);
    }

    return this;
  }

  /**
   * Add the given values to the beginning of the given column
   * If the given column does not exists, it will be created
   * If the given value exists but not an array it will be ignored
   */
  public unshift(column: keyof Schema, ...values: any[]) {
    const currentValue = this.get(column);

    if (Array.isArray(currentValue)) {
      this.set(column, [...values, ...currentValue]);
    } else if (!currentValue) {
      this.set(column, values);
    }

    return this;
  }

  /**
   * Add the given values to the beginning of the given column only if not exists
   */
  public unshiftOnce(column: keyof Schema, ...values: any[]) {
    const currentValue = this.get(column);

    if (Array.isArray(currentValue)) {
      const newValues = Array.from(new Set([...values, ...currentValue]));
      this.set(column, newValues);
    } else if (!currentValue) {
      this.set(column, values);
    }

    return this;
  }

  protected async prepareDataForCreating(
    cast: boolean = true,
    triggerEvents: boolean = true,
  ) {
    // await this.getDatabase().startSessionContext(async ({ session }) => {
    // check for default values and merge it with the data
    await this.checkDefaultValues();

    // if the column does not exist, then create it
    if (
      (!this.data.id || !this.autoGeneratedId) &&
      this.getStaticProperty("autoGenerateId")
    ) {
      this.autoGeneratedId = true;
      await this.generateNextId();
    }

    const now = new Date();

    const createdAtColumn = this.createdAtColumn;

    // if the column does not exist, then create it
    if (createdAtColumn && !this.data[createdAtColumn]) {
      this.data[createdAtColumn] = now;
    }

    // if the column does not exist, then create it
    const updatedAtColumn = this.updatedAtColumn;

    if (updatedAtColumn) {
      this.data[updatedAtColumn] = now;
    }

    if (cast) {
      await this.castData();
    }

    if (triggerEvents) {
      const selfModelEvents = this.getModelEvents();

      const ModelEvents = this.getBaseModelEvents();

      await this.onSaving();
      await this.onCreating();
      await selfModelEvents.trigger("creating", this);
      await selfModelEvents.trigger("saving", this);
      await ModelEvents.trigger("creating", this);
      await ModelEvents.trigger("saving", this);
    }
  }

  /**
   * Perform saving operation either by updating or creating a new record in database
   */
  public async save(
    mergedData?: Omit<Schema, "id" | "_id">,
    {
      triggerEvents = true,
      cast = true,
      forceUpdate = false,
    }: {
      triggerEvents?: boolean;
      cast?: boolean;
      forceUpdate?: boolean;
    } = {},
  ) {
    const isNewModel = this.isNewModel();
    try {
      if (mergedData) {
        this.merge(mergedData);
      }

      // const logLevel = getDatabaseDebugLevel();

      let currentModel;

      // check if the data contains the primary id column
      if (!isNewModel) {
        // perform an update operation
        // check if the data has changed
        // if not changed, then do not do anything

        if (cast) {
          // this.logInfo("Casting data before saving");
          await this.castData(forceUpdate);
          // this.logInfo("Data has been casted");
        }

        if (this.shouldUpdate(this.originalData, this.data) === false) {
          return this;
        }

        currentModel = new (this.constructor as any)(this.originalData);

        const updatedAtColumn = this.updatedAtColumn;

        if (updatedAtColumn) {
          // updateAtColumn is supposed to be part of the Schema
          (this.data as any)[updatedAtColumn] = new Date();
        }

        if (triggerEvents) {
          const selfModelEvents = this.getModelEvents();

          const ModelEvents = this.getBaseModelEvents();

          await this.onSaving();
          await this.onUpdating();
          await selfModelEvents.trigger("updating", this, currentModel);
          await selfModelEvents.trigger("saving", this, currentModel);
          await ModelEvents.trigger("updating", this, currentModel);
          await ModelEvents.trigger("saving", this, currentModel);
        }

        // const data = { ...this.data };

        // if (isPlainObject(data._id)) {
        //   delete data._id;
        // }

        const filter: GenericObject = {};

        if (isEmpty(this._id)) {
          filter._id = this.data._id;
        } else {
          filter.id = this.id;
        }

        await this.getQuery().replace(this.getCollection(), filter, this.data);

        if (triggerEvents) {
          this.triggerUpdatedEvents(currentModel);
        }
      } else {
        let tries = 3;

        while (tries > 0) {
          try {
            await this.prepareDataForCreating(cast, triggerEvents);

            this.data = (await this.getQuery().create(
              this.getCollection(),
              this.data,
            )) as Schema;

            if (triggerEvents) {
              this.triggerCreatedEvents();
            }

            break;
          } catch (error: MongoServerError | any) {
            console.log(error);
            // Handle duplicate key error
            if (error instanceof MongoServerError && error.code === 11000) {
              if (tries < 2) {
                const duplicateField = error.keyValue;
                const fieldName = Object.keys(duplicateField)[0];

                const errorMessage = `A record with the same ${fieldName} already exists.`;
                if (this.autoGeneratedId) {
                  this.unset("id");
                }

                throw new Error(errorMessage);
              } else {
                tries--;
              }
            }

            throw error;
          }
        }
      }

      if (!this.data.id) return this;

      this.originalData = clone(this.data);

      // @see constructor
      this.originalData._id = this.data._id;

      return this;
    } catch (error) {
      console.log("Error in " + this.constructor.name + ".save()");

      console.log(error);
      throw error;
    }
  }

  /**
   * Serialize the model data for storage in database
   */
  public serialize() {
    return {
      ...this.data,
      _id: this.data._id ? this.data._id.toString() : undefined,
    };
  }

  /**
   * Generate and return next id
   */
  public async generateNextId() {
    this.set(
      "id",
      await this.getStaticProperty("genNextId").bind(this.constructor)(),
    );

    return this.id;
  }

  /**
   * Trigger created events
   */
  public triggerCreatedEvents() {
    const selfModelEvents = this.getModelEvents();
    const ModelEvents = this.getBaseModelEvents();

    this.onSaved();
    this.onCreated();
    selfModelEvents.trigger("created", this);
    selfModelEvents.trigger("saved", this);
    ModelEvents.trigger("created", this);
    ModelEvents.trigger("saved", this);

    this.startSyncing("create");
  }

  /**
   * Trigger updated events
   */
  public triggerUpdatedEvents(oldModel: Model) {
    const selfModelEvents = this.getModelEvents();
    const ModelEvents = this.getBaseModelEvents();

    this.onSaved();
    this.onUpdated();
    selfModelEvents.trigger("updated", this, oldModel);
    selfModelEvents.trigger("saved", this, oldModel);
    ModelEvents.trigger("updated", this, oldModel);
    ModelEvents.trigger("saved", this, oldModel);

    this.startSyncing("update", oldModel);
  }

  /**
   * Perform saving but without any events triggers
   */
  public async silentSaving(
    mergedData?: Omit<Schema, "id" | "_id">,
    options?: { cast?: boolean },
  ) {
    return await this.save(mergedData, {
      triggerEvents: false,
      ...(options || {}),
    });
  }

  /**
   * Determine whether the model should be updated or not
   */
  protected shouldUpdate(originalData: Schema, data: Schema) {
    return areEqual(originalData, data) === false;
  }

  /**
   * Triggered before saving the model either by creating or updating
   */
  protected async onSaving() {
    //
  }

  /**
   * Triggered after saving the model either by creating or updating
   */
  protected async onSaved() {
    //
  }

  /**
   * Triggered before creating the model
   */
  protected async onCreating() {
    //
  }

  /**
   * Triggered after creating the model
   */
  protected async onCreated() {
    //
  }

  /**
   * Triggered before updating the model
   */
  protected async onUpdating() {
    //
  }

  /**
   * Triggered after updating the model
   */
  protected async onUpdated() {
    //
  }

  /**
   * Triggered before deleting the model
   */
  protected async onDeleting() {
    //
  }

  /**
   * Triggered after deleting the model
   */
  protected async onDeleted() {
    //
  }

  /**
   * Cast data before saving
   */
  protected async castData(forceUpdate = false) {
    for (const column in this.casts) {
      if (!forceUpdate && !this.isDirty(column)) {
        continue;
      }

      let value = this.get(column);

      if (value === undefined) continue;

      const castType = this.casts[column];

      const castValue = async (value: any) => {
        if (castType.prototype instanceof Model) {
          // if cast type is passed as model class, then get its embedded data
          value = await castModel(castType)(value);
        } else if (castType?.model) {
          // it means the user is passing a custom model embedding i.e Model.embed('embedToProduct') => Product to embed from the getter property
          // embedToProduct
          // @see EmbeddedModel

          value = await castModel(castType.model, castType.embeddedKey)(value);
        } else if (typeof castType === "object") {
          // it means the user is passing an enum object

          value = await castEnum(castType)(value);
        } else if (value instanceof Model) {
          value = value.embeddedData;
        } else if (typeof castType === "function") {
          value = await (castType as CustomCastType)(value, column, this);
        } else {
          value = this.castValue(value, castType);
        }

        return value;
      };

      // if the cast type is passed in array
      // it means we just need to pass the value to the first function
      // second argument will be the column name
      // and the third argument will be the model instance
      if (Array.isArray(castType)) {
        value = await castType[0](value, column, this);
      } else if (Array.isArray(value) && castType !== "localized") {
        // if cast type is array, then we'll keep the value as it is

        // now we want to add a new validation rule that to check
        // if the value is an array of localized objects
        // if so, then each value in the array should have `localeCode` and `value` keys
        // if so, then it will be cast only to the value key inside each object
        // so the final output will be localeCode and `castValue` of the value key
        if (castType === "array") {
          // just do nothing we're good for now
          // TODO: Enhance the if statement
        } else if (value[0]?.localeCode && value[0]?.value) {
          value = await Promise.all(
            value.map(async item => {
              return {
                localeCode: item.localeCode,
                value: await castValue(item.value),
              };
            }),
          );
        } else {
          value = await Promise.all(
            value.map(async item => {
              return await castValue(item);
            }),
          );
        }
      } else {
        value = await castValue(value);
      }

      if (Array.isArray(value)) {
        value = value.filter(value => value !== null && value !== undefined);
      }

      if (value !== undefined) {
        this.set(column, value);
      } else {
        this.unset(column);
      }
    }

    for (const column in this.customCasts) {
      const castType = this.customCasts[column];

      const value = await castType(this, column);

      if (value !== undefined) {
        this.set(column, value);
      } else {
        this.unset(column);
      }
    }
  }

  /**
   * Return only the given columns to be used in output
   */
  public outputOnly(columns: string[]) {
    return this.clone(this.only(columns));
  }

  /**
   * Return all columns except the given columns to be used in output
   */
  public outputExcept(columns: string[]) {
    return this.clone(this.except(columns));
  }

  /**
   * Cast the given value based on the given cast type
   */
  protected castValue(value: any, castType: CastType) {
    const isEmptyValue = isEmpty(value);

    if (typeof value === "object") {
      if (value === null) return undefined;
    } else if (isEmptyValue) return undefined;

    switch (castType) {
      case "string":
        return isEmptyValue ? "" : String(value).trim();
      case "localized":
        // if (isEmptyValue) return [];

        // if (!Array.isArray(value)) return [];
        if (!Array.isArray(value)) return undefined;

        return value
          .filter(value => !isEmpty(value) && isPlainObject(value))
          .map(item => {
            return {
              localeCode: item.localeCode,
              value: item.value,
            };
          });
      case "number":
        // return isEmptyValue ? 0 : Number(value);
        return Number(value);
      case "int":
      case "integer":
        // return isEmptyValue ? 0 : parseInt(value);
        return parseInt(value);
      case "float":
        // return isEmptyValue ? 0 : parseFloat(value);
        return parseFloat(value);
      case "bool":
      case "boolean": {
        // if (isEmptyValue) return false;

        if (value === "true") return true;

        if (value === "false" || value === "0" || value === 0) return false;

        return Boolean(value);
      }
      case "date": {
        if (dayjs.isDayjs(value)) {
          value = value.toDate();
        }

        if (value instanceof Date) {
          return toUTC(value);
        }

        return toUTC(new Date(value));
      }
      case "location": {
        // if (isEmptyValue) return null;

        const lat = value?.[0] || value?.lat;
        const lng = value?.[1] || value?.lng;
        const address = value?.address || value?.formattedAddress;

        return {
          type: "Point",
          coordinates: [Number(lat), Number(lng)],
          address,
        };
      }
      case "object": {
        // if (isEmptyValue) return {};

        if (typeof value === "string") {
          try {
            return JSON.parse(value);
          } catch (error) {
            return undefined;
          }
        }

        return value;
      }
      case "array": {
        // if (isEmptyValue) return [];

        if (typeof value === "string") {
          return JSON.parse(value);
        }

        return value;
      }
      case "mixed":
      case "any":
      default:
        return value;
    }
  }

  /**
   * Check for default values
   */
  protected checkDefaultValues() {
    // if default value is empty, then do nothing
    if (isEmpty(this.defaultValue)) return;

    const defaultValue = { ...this.defaultValue };

    for (const key in defaultValue) {
      const value = defaultValue[key];

      if (typeof value === "function") {
        defaultValue[key] = value(this);
      }
    }

    // merge the data with default value
    this.data = merge(defaultValue, this.data);
  }

  /**
   * Destroy the model and delete it from database collection
   */
  public async destroy() {
    if (!this.data._id) return;

    if (this.deletedAtColumn) {
      this.set(this.deletedAtColumn, new Date());
    }

    const deleteStrategy: ModelDeleteStrategy =
      this.getStaticProperty("deleteStrategy");

    if (deleteStrategy === ModelDeleteStrategy.moveToTrash) {
      const collectionName = this.getCollection();
      class Trash extends Model {
        public static collection = collectionName + "Trash";
      }

      // we need to wrap the trash collection inside a model class so it get a generated timestamps and id
      Trash.create({
        document: this.data,
      });
    }

    const selfModelEvents = this.getModelEvents();

    const ModelEvents = this.getBaseModelEvents();

    await this.onDeleting();
    await selfModelEvents.trigger("deleting", this);
    await ModelEvents.trigger("deleting", this);

    // the document will be deleted from database collection if the delete strategy is not soft delete
    if (deleteStrategy !== ModelDeleteStrategy.softDelete) {
      await this.getQuery().deleteOne(this.getCollection(), {
        _id: this.data._id,
      });
    } else if (deleteStrategy === ModelDeleteStrategy.softDelete) {
      await this.getQuery().updateOne(
        this.getCollection(),
        {
          _id: this.data._id,
        },
        this.data,
      );
    }

    this.onDeleted();

    selfModelEvents.trigger("deleted", this);
    ModelEvents.trigger("deleted", this);

    this.syncDestruction();
  }

  /**
   * Determine if the given column is dirty column
   *
   * Dirty columns are columns that their values have been changed from the original data
   */
  public isDirty(column?: string) {
    if (!column) {
      return areEqual(clone(this.data), clone(this.originalData)) === false;
    }

    if (this.isNewModel()) return true;

    const currentValue = get(this.data, column);
    const originalValue = get(this.originalData, column);

    return areEqual(clone(currentValue), clone(originalValue)) === false;
  }

  /**
   * Check if current model is a new model
   */
  public isNewModel() {
    // Check initial data instead of current data since it represents
    // the original state when the model was instantiated
    const hasMongoId = Boolean(this.data._id) && !this.isRestored;

    // Check for numeric id in initial data
    // const hasNumericId = Boolean(this.data?.id) && !this.isRestored;

    return !hasMongoId;
  }

  /**
   * Get embedded data
   */
  public get embeddedData() {
    if (this.embedAllExcept.length > 0) {
      return except(this.data, this.embedAllExcept as string[]);
    }

    if (this.embedAllExceptTimestampsAndUserColumns) {
      return except(this.data, [
        this.createdAtColumn,
        this.updatedAtColumn,
        this.deletedAtColumn,
        this.createdByColumn,
        this.updatedByColumn,
        this.deletedByColumn,
      ]);
    }

    return this.embedded.length > 0 ? this.only(this.embedded) : this.data;
  }

  /**
   * Clone the model
   */
  public clone(data: Document = this.data) {
    return new (this.constructor as any)(clone(data)) as this;
  }

  /**
   * Get relationship with the given model class
   */
  public hasMany<T extends Model = Model>(
    modelClass: typeof Model,
    column: string,
  ) {
    return new RelationshipWithMany<T>(this as any, modelClass, column);
  }

  /**
   * Get new aggregate for current model
   */
  public static aggregate<T extends Model = Model>(this: ChildModel<T>) {
    return new ModelAggregate<T>(this);
  }

  /**
   * @alias aggregate
   */
  public static newQuery(): ModelAggregate<Model> {
    return this.aggregate();
  }

  /**
   * Get query builder
   * @alias aggregate
   */
  public static queryBuilder<T extends Model = Model>(this: ChildModel<T>) {
    return new ModelAggregate<T>(this);
  }

  /**
   * Sync with the given model
   */
  public static sync(columns: string | string[], embedMethod = "embedData") {
    return new ModelSync(this as typeof Model, columns, embedMethod);
  }

  /**
   * Sync data on saving
   */
  public startSyncing(saveMode: "create" | "update", oldModel?: Model) {
    for (const modelSync of this.syncWith) {
      modelSync.sync(this as any, saveMode, oldModel);
    }
  }

  /**
   * Sync destruction
   * Called when destroy method is called
   */
  public syncDestruction() {
    for (const modelSync of this.syncWith) {
      modelSync.syncDestruction(this as any);
    }
  }

  /**
   * The syncing model (That calls startSyncing) is being embedded in multiple documents of current model
   * I.e Country.syncMany('cities') while current model is City
   */
  public static syncMany(
    columns: string | string[],
    embedMethod = "embedData",
  ) {
    return new ModelSync(this as typeof Model, columns, embedMethod).syncMany();
  }

  /**
   * Reassociate a model/object/document with the current model
   * If the model is already associated, it will be updated
   * If not, it will be associated
   * the model/document must have an id
   *
   * If it is a model, you can set the embed method to use
   */
  public reassociate(
    this: Model,
    column: string,
    model: Model | ModelDocument | any,
    embedWith?: string,
  ) {
    const columnValue =
      model instanceof Model
        ? embedWith
          ? (model as any)[embedWith]()
          : model.embeddedData
        : model;

    if (columnValue === undefined) return this;

    // make a deep copy so when changing the data, it won't affect the original data
    const documentsList = clone(this.get(column, []));

    const index = documentsList.findIndex(
      (doc: any) => (doc?.id || doc) === (columnValue?.id || columnValue),
    );

    if (index === -1) {
      documentsList.push(columnValue);
    } else {
      documentsList[index] = columnValue;
    }

    this.set(column, [...documentsList]);

    return this;
  }

  /**
   * Associate a model with the current model
   */
  public associate(
    this: Model,
    column: string,
    model: Model | ModelDocument | any,
    embedWith?: string,
  ) {
    const columnValue =
      model instanceof Model
        ? embedWith
          ? (model as any)[embedWith]()
          : model.embeddedData
        : model;

    if (columnValue === undefined) return this;

    const documentsList = this.get(column, []);

    documentsList.push(columnValue);

    this.set(column, documentsList);

    return this;
  }

  /**
   * Disassociate a model with the current model
   */
  public disassociate(
    this: Model,
    column: string,
    model: Model | ModelDocument | any,
  ) {
    const columnValue = model instanceof Model ? model.embeddedData : model;

    if (columnValue === undefined) return this;

    const documentsList = this.get(column, []);

    if (!Array.isArray(documentsList)) return this;

    const index = documentsList.findIndex(
      (doc: any) => (doc?.id || doc) === (columnValue?.id || columnValue),
    );

    if (index !== -1) {
      documentsList.splice(index, 1);
    }

    this.set(column, documentsList);

    return this;
  }

  /**
   * Refresh the model with new data from database
   * This method will update the current data with the new data from database
   */
  public async refresh() {
    const key = this.data._id ? "_id" : "id";
    const value = this.data._id ?? this.data.id;
    const data = await this.getQuery().first(this.getCollection(), {
      [key]: value,
    });

    if (!data) return;

    this.data = data;

    return this;
  }

  /**
   * Fetch data from database and return it in a new model
   */
  public async reload(): Promise<this> {
    const key = this.data._id ? "_id" : "id";
    const value = this.data._id ?? this.data.id;

    if (!value) {
      throw new Error("Model ID is required to reload the model");
    }

    const data = await this.getQuery().first(this.getCollection(), {
      [key]: value,
    });

    return new (this.constructor as any)(data);
  }

  /**
   * Make a wrapper to list when models should be updated when only one of the given columns is updated
   */
  public syncUpdateWhenChange(
    columns: string | string[],
    syncModels: ModelSync[],
  ) {
    return syncModels.map(syncModel => {
      syncModel.updateWhenChange(columns);

      return syncModel;
    });
  }

  /**
   * Get a Joinable instance for current model
   */
  public static joinable(
    /**
     * Local field to the current model
     */
    localField?: string,
    /**
     * Foreign field in the joinable model
     */
    foreignField?: string,
    single?: boolean,
    as?: string,
  ) {
    const joinable = new Joinable(this as any);

    if (localField) {
      joinable.localField(localField);
    }

    if (foreignField) {
      joinable.foreignField(foreignField);
    }

    if (single) {
      joinable.single(single);
    }

    if (as) {
      joinable.as(as);
    }

    return joinableProxy(joinable);
  }
}

export type ModelType = typeof Model;
